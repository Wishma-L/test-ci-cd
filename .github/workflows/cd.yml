name: Continuous Deployment

# Run on main branch after CI workflow has completed on main.
on:
  workflow_run:
    workflows: ["Continuous Integration"]
    branches: [main]
    types: [completed]

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Only go ahead with the job if CI completed successfully (i.e. tests passed).
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
          steps:
            # Checkout project source
            - name: Checkout source
              uses: actions/checkout@v1

            # Install Node.js dependency
            - name: Setup node
              uses: actions/setup-node@v2
              with:
              node-version: "16"
              cache: "npm"

            # Install package.json dependencies
            - name: Install
              run: npm install

            # A simple bash script to generate the .env file from repository secrets.
            # This is to avoid hard-coding urls for services such as analytics and search.
            # For production, its important to run this step BEFORE building the site because
            # its a static site, and so environment variables are used at build time rather
            # than run time.
            # - name: Generate prod env file
            #   env:
            #     CONTENTFUL_ACCESS_TOKEN: ${{ secrets.CONTENTFUL_ACCESS_TOKEN }}
            #     CONTENTFUL_SPACE_ID: ${{ secrets.CONTENTFUL_SPACE_ID }}
            #     ENABLE_GATSBY_REFRESH_ENDPOINT: ${{ secrets.ENABLE_GATSBY_REFRESH_ENDPOINT }}
            #     ENVIRONMENT_ID: ${{ secrets.ENVIRONMENT_ID }}
            #     GATSBY_ENVIRONMENT_ID: ${{ secrets.GATSBY_ENVIRONMENT_ID }}
            #     GATSBY_CONTENTFUL_ACCESS_TOKEN: ${{ secrets.GATSBY_CONTENTFUL_ACCESS_TOKEN }}
            #     GATSBY_CONTENTFUL_SPACE_ID: ${{ secrets.GATSBY_CONTENTFUL_SPACE_ID }}
            #     GATSBY_CONTENTFUL_MANAGEMENT_ACCESS_TOKEN: ${{ secrets.GATSBY_CONTENTFUL_MANAGEMENT_ACCESS_TOKEN }}
            #     GATSBY_KEYCLOAK_URL: ${{ secrets.GATSBY_KEYCLOAK_URL }}
            #     GATSBY_KEYCLOAK_CLIENT_ID: ${{ secrets.GATSBY_KEYCLOAK_CLIENT_ID }}
            #     GATSBY_APP_URL: ${{ secrets.GATSBY_APP_URL }}

            #     run: |
            #           touch .env.production
            #           echo CONTENTFUL_ACCESS_TOKEN="$CONTENTFUL_ACCESS_TOKEN" >> .env.production
            #           echo CONTENTFUL_SPACE_ID="$CONTENTFUL_SPACE_ID" >> .env.production
            #           echo ENABLE_GATSBY_REFRESH_ENDPOINT="$ENABLE_GATSBY_REFRESH_ENDPOINT" >> .env.production
            #           echo ENVIRONMENT_ID="$ENVIRONMENT_ID" >> .env.production
            #           echo GATSBY_ENVIRONMENT_ID="$GATSBY_ENVIRONMENT_ID" >> .env.production
            #           echo GATSBY_CONTENTFUL_ACCESS_TOKEN="$GATSBY_CONTENTFUL_ACCESS_TOKEN" >> .env.production
            #           echo GATSBY_CONTENTFUL_SPACE_ID="$GATSBY_CONTENTFUL_SPACE_ID" >> .env.production
            #           echo CONTENTFUL_SPACE_ID="$CONTENTFUL_SPACE_ID" >> .env.production
            #           echo GATSBY_CONTENTFUL_MANAGEMENT_ACCESS_TOKEN="$GATSBY_CONTENTFUL_MANAGEMENT_ACCESS_TOKEN" >> .env.production
            #           echo GATSBY_KEYCLOAK_URL="$GATSBY_KEYCLOAK_URL" >> .env.production
            #           echo GATSBY_KEYCLOAK_CLIENT_ID="$GATSBY_KEYCLOAK_CLIENT_ID" >> .env.production
            #           echo GATSBY_APP_URL="$GATSBY_APP_URL" >> .env.production
            #     shell: bash

            # Run the production build - this runs: gatsby build
            # which generates the "public" directory containing the entire site.
            - name: Build
              run: npm run build

            # Use a community action from the Actions Marketplace to deploy
            # the "public" directory generated by the build to Github Pages.
            - name: Deploy to Github Pages
              uses: peaceiris/actions-gh-pages@v3
              with:
                github_token: ${{ secrets.GITHUB_TOKEN }}
                publish_dir: ./public

            # # Finally, ingest the search.sql file (also generated by the build)
            # # into the Heroku database for the application hosting the search service.
            # - name: Ingest search docs
            #   env:
            #   HEROKU_APP_NAME: ${{ secrets.HEROKU_APP_NAME }}
            #   HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
            #   run: |
            #             HEROKU_API_KEY=$HEROKU_API_KEY cat search.sql | heroku pg:psql --app $HEROKU_APP_NAME
            #   shell: bash
